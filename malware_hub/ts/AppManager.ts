/*
Service that manages app page state.
Allows one page to call another page with sepcified arugements.

This service is the foundation for modular, single-page applicatons

AppManager expects pages to be templetes, instead of fully fledged pages.

This means that vistors can't directly visit subpages, instead they would need
to visit the index page to route to the appropriate subpage.
 
This is done by using the "?AppManagerRoute" query paramter, along with the "?AppManagerArguments" query 
to appropriately route and pass arguments to the pages.
*/

class generic{

    __transition_to_func :  ( () => HTMLElement )
    __load_func? : ( (event? : any) => any ) 
    private page_id : string;
    constructor(page_id : string){
        this.page_id = page_id
        // default __transition_to_func
        this.__transition_to_func = function(){
            return document.getElementById(this.page_id) as HTMLElement
        }
    }
    transition_element(func : (returned_page: HTMLElement) => HTMLElement){

        this.__transition_to_func = function(){

            let cached_page = document.getElementById(this.page_id) as HTMLElement
            let selected_page = func(cached_page)

            if (!selected_page){
                return cached_page
            }

            return selected_page
        }

        return this
    }

    load(func : (returned_page : HTMLElement,event? : any) => any){
        this.__load_func = function(event){
            let cached_page = document.getElementById(this.page_id) as HTMLElement
            func(cached_page,event)
        }
        return this
    }
}

type events = {
    [key : string] : {
        on_show : generic
        on_hide : generic
    }
}

let app_element = document.querySelector("body app")
let current_page : string = ""
let events : events = {}
let virtual_url = location.origin + location.pathname
let navagating = false

function debug(string : string){
    console.log("[AppManager] " + string)
}

export function AddPage(){

    // let page_id = (new URL(page_location,virtual_url)).toString()
    let on_show = new generic(virtual_url)
    let on_hide = new generic(virtual_url)

    events[virtual_url] = {
        on_show,
        on_hide
    }

    return {on_show,on_hide}

}

export function NavagateTo(page_location : string, state : any){
    // Navagates to next page.
    // Fetches the page if not cached.

    if (navagating){
        debug("Currently Navagating")
        return
    }

    navagating = true
    virtual_url = new URL(page_location,virtual_url).toString()
    let page_id = virtual_url

    debug("Loading " + virtual_url)
    // look for cached page
    let cached_page = document.getElementById(page_id)

    function navagate(){

        let future_page_event = events[page_id]
        let previous_page_event = events[current_page]

        let future_page = future_page_event.on_show.__transition_to_func()
        let previous_page : HTMLElement | undefined
     
        if (previous_page_event){
            previous_page = previous_page_event.on_hide.__transition_to_func()
        }

        if (previous_page){
            // phase out
            previous_page.style.opacity = "0"
            
            previous_page.addEventListener("transitionend",function(){
                future_page.style.opacity = "1"
                future_page_event.on_show.__load_func?.(state)
                previous_page_event.on_hide.__load_func?.()
            },{once : true})

        } else {
            future_page.style.height = "auto"
            future_page.style.opacity = "1"
            future_page_event.on_show.__load_func?.(state)
        }

        current_page = page_id
        
    }

    if (!cached_page){

        fetch(virtual_url)
        .then(function(response){
            return response.text()
        })
        .then(function(html){
            // set zindex 0 & display none
            let page = document.createElement("page")

            page.innerHTML = html
            page.id = page_id

            page.style.transition = "all .3s ease-in"
            page.style.opacity = "0"
            page.style.height = "0px"

            app_element?.appendChild(page)

            // load the scripts in
            let scripts = page.querySelectorAll("script")
            let loaded = 0
            let max_load = scripts.length

            scripts.forEach(function(script){
                
                let new_script = document.createElement("script")
                new_script.innerHTML = script.innerHTML
                new_script.async = false
                new_script.defer = false
                new_script.setAttribute("type","module")
                new_script.src = script.src

                script.parentNode?.appendChild(
                    new_script
                )
                
                new_script.addEventListener("load",function(){
                    loaded +=1

                    if (loaded >= max_load){
                        debug("All scripts are now loaded, loading page.")
                        navagate()
                    }
                },{once : true})
                
            })

        })
        .catch(function(){
            debug("Error while loading page.")
        })

    }

    navagate()

}
